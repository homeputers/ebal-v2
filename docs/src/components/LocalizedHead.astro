---
import config from 'virtual:starlight/user-config';
import { defaultSiteLocale, siteLocaleMeta } from '../config/siteMeta.js';

const { entry, lang, locale } = Astro.props;
const { data } = entry;

const canonical = Astro.site ? new URL(Astro.url.pathname, Astro.site) : undefined;
const activeLocale = locale ?? config.defaultLocale?.locale ?? defaultSiteLocale;
const siteMeta = siteLocaleMeta[activeLocale] ?? siteLocaleMeta[defaultSiteLocale] ?? {
  title: config.title,
  description: config.description
};
const siteTitle = siteMeta.title ?? config.title;
const fallbackDescription = siteMeta.description ?? config.description;
const description = data.description || fallbackDescription;

const basePath = import.meta.env.BASE_URL.replace(/\/$/, '');

function stripLeadingSlash(value) {
  return value.replace(/^\/+/, '');
}

function withBase(path) {
  const value = stripLeadingSlash(path ?? '');
  return value ? `${basePath}/${value}` : basePath || '/';
}

function localizedUrl(url, localeCode) {
  const nextUrl = new URL(url);
  if (!config.locales) {
    return nextUrl;
  }
  const target = localeCode === 'root' ? '' : localeCode;
  const hasBase = nextUrl.pathname.startsWith(basePath);
  if (hasBase) {
    nextUrl.pathname = nextUrl.pathname.slice(basePath.length);
  }
  const htmlExt = '.html';
  const [_, segment = ''] = nextUrl.pathname.split('/');
  const isRootHtml = segment.endsWith(htmlExt);
  const baseSlug = isRootHtml ? segment.slice(0, -htmlExt.length) : segment;
  if (baseSlug && config.locales[baseSlug]) {
    if (target) {
      nextUrl.pathname = nextUrl.pathname.replace(baseSlug, target);
    } else if (isRootHtml) {
      nextUrl.pathname = '/index.html';
    } else {
      nextUrl.pathname = nextUrl.pathname.replace('/' + baseSlug, '');
    }
  } else if (target) {
    if (segment === 'index.html') {
      nextUrl.pathname = `/${target}.html`;
    } else {
      nextUrl.pathname = `/${target}${nextUrl.pathname}`;
    }
  }
  if (hasBase) {
    nextUrl.pathname = basePath + nextUrl.pathname;
  }
  return nextUrl;
}

function normalize(entry) {
  return {
    tag: entry.tag,
    attrs: { ...(entry.attrs ?? {}) },
    content: entry.content ?? ''
  };
}

function hasTag(head, entry) {
  switch (entry.tag) {
    case 'title':
      return head.some(({ tag }) => tag === 'title');
    case 'meta':
      return hasOneOf(head, entry, ['name', 'property', 'http-equiv']);
    default:
      return false;
  }
}

function hasOneOf(head, entry, keys) {
  const attr = getAttr(keys, entry);
  if (!attr) return false;
  const [key, value] = attr;
  return head.some(({ tag, attrs }) => tag === entry.tag && attrs[key] === value);
}

function getAttr(keys, entry) {
  for (const key of keys) {
    const value = entry.attrs[key];
    if (value) return [key, value];
  }
}

function mergeHead(base, additions) {
  const next = [...base];
  for (const entry of additions) {
    if (!entry?.tag) continue;
    const normalized = normalize(entry);
    const existingIndex = next.findIndex((item) => hasTag([normalized], item));
    if (existingIndex >= 0) {
      next.splice(existingIndex, 1);
    }
    next.push(normalized);
  }
  return next;
}

function getImportance(entry) {
  if (entry.tag === 'meta' && ('charset' in entry.attrs || 'http-equiv' in entry.attrs || entry.attrs.name === 'viewport')) {
    return 100;
  }
  if (entry.tag === 'title') return 90;
  if (entry.tag !== 'meta') {
    if (entry.tag === 'link' && entry.attrs.rel === 'shortcut icon') {
      return 70;
    }
    return 80;
  }
  return 0;
}

function sortHead(head) {
  return head.sort((a, b) => {
    const aImportance = getImportance(a);
    const bImportance = getImportance(b);
    return aImportance > bImportance ? -1 : bImportance > aImportance ? 1 : 0;
  });
}

function createHead(defaults, ...heads) {
  let result = Array.isArray(defaults) ? defaults.map(normalize) : [];
  for (const head of heads) {
    if (!Array.isArray(head)) continue;
    result = mergeHead(result, head);
  }
  return sortHead(result);
}

const headDefaults = [
  { tag: 'meta', attrs: { charset: 'utf-8' } },
  {
    tag: 'meta',
    attrs: { name: 'viewport', content: 'width=device-width, initial-scale=1' }
  },
  { tag: 'title', content: `${data.title} ${config.titleDelimiter} ${siteTitle}` },
  { tag: 'link', attrs: { rel: 'canonical', href: canonical?.href } },
  { tag: 'meta', attrs: { name: 'generator', content: Astro.generator } },
  {
    tag: 'link',
    attrs: {
      rel: 'shortcut icon',
      href: withBase(config.favicon.href),
      type: config.favicon.type
    }
  },
  { tag: 'meta', attrs: { property: 'og:title', content: data.title } },
  { tag: 'meta', attrs: { property: 'og:type', content: 'article' } },
  { tag: 'meta', attrs: { property: 'og:url', content: canonical?.href } },
  { tag: 'meta', attrs: { property: 'og:locale', content: lang } },
  { tag: 'meta', attrs: { property: 'og:description', content: description } },
  { tag: 'meta', attrs: { property: 'og:site_name', content: siteTitle } },
  {
    tag: 'meta',
    attrs: { name: 'twitter:card', content: 'summary_large_image' }
  },
  { tag: 'meta', attrs: { name: 'twitter:title', content: data.title } },
  { tag: 'meta', attrs: { name: 'twitter:description', content: description } }
];

if (description) {
  headDefaults.push({
    tag: 'meta',
    attrs: { name: 'description', content: description }
  });
}

if (canonical && config.isMultilingual) {
  for (const localeCode in config.locales) {
    const localeOpts = config.locales[localeCode];
    if (!localeOpts) continue;
    headDefaults.push({
      tag: 'link',
      attrs: {
        rel: 'alternate',
        hreflang: localeOpts.lang,
        href: localizedUrl(canonical, localeCode).href
      }
    });
  }
}

if (Astro.site) {
  headDefaults.push({
    tag: 'link',
    attrs: {
      rel: 'sitemap',
      href: withBase('/sitemap-index.xml')
    }
  });
}

if (config.social?.twitter) {
  headDefaults.push({
    tag: 'meta',
    attrs: {
      name: 'twitter:site',
      content: new URL(config.social.twitter.url).pathname
    }
  });
}

const head = createHead(headDefaults, config.head, data.head);
---

{head.map(({ tag: Tag, attrs, content }) => <Tag {...attrs} set:html={content} />)}
